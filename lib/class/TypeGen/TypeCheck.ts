// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class TypeCheck implements flatbuffers.IUnpackableObject<TypeCheckT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TypeCheck {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTypeCheck(bb:flatbuffers.ByteBuffer, obj?:TypeCheck):TypeCheck {
  return (obj || new TypeCheck()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTypeCheck(bb:flatbuffers.ByteBuffer, obj?:TypeCheck):TypeCheck {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TypeCheck()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

byte():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
}

int8():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
}

ubyte():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

uint8():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

bool():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

short():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 0;
}

int16():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 0;
}

ushort():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

uint16():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

int():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

int32():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

uint():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

uint32():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

float():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

float32():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

long():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

int64():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

ulong():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

uint64():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

double():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

float64():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

string():string|null
string(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
string(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startTypeCheck(builder:flatbuffers.Builder) {
  builder.startObject(22);
}

static add_byte(builder:flatbuffers.Builder, byte:number) {
  builder.addFieldInt8(0, byte, 0);
}

static add_int8(builder:flatbuffers.Builder, int8:number) {
  builder.addFieldInt8(1, int8, 0);
}

static add_ubyte(builder:flatbuffers.Builder, ubyte:number) {
  builder.addFieldInt8(2, ubyte, 0);
}

static add_uint8(builder:flatbuffers.Builder, uint8:number) {
  builder.addFieldInt8(3, uint8, 0);
}

static add_bool(builder:flatbuffers.Builder, bool:boolean) {
  builder.addFieldInt8(4, +bool, +false);
}

static add_short(builder:flatbuffers.Builder, short:number) {
  builder.addFieldInt16(5, short, 0);
}

static add_int16(builder:flatbuffers.Builder, int16:number) {
  builder.addFieldInt16(6, int16, 0);
}

static add_ushort(builder:flatbuffers.Builder, ushort:number) {
  builder.addFieldInt16(7, ushort, 0);
}

static add_uint16(builder:flatbuffers.Builder, uint16:number) {
  builder.addFieldInt16(8, uint16, 0);
}

static add_int(builder:flatbuffers.Builder, int:number) {
  builder.addFieldInt32(9, int, 0);
}

static add_int32(builder:flatbuffers.Builder, int32:number) {
  builder.addFieldInt32(10, int32, 0);
}

static add_uint(builder:flatbuffers.Builder, uint:number) {
  builder.addFieldInt32(11, uint, 0);
}

static add_uint32(builder:flatbuffers.Builder, uint32:number) {
  builder.addFieldInt32(12, uint32, 0);
}

static add_float(builder:flatbuffers.Builder, float:number) {
  builder.addFieldFloat32(13, float, 0.0);
}

static add_float32(builder:flatbuffers.Builder, float32:number) {
  builder.addFieldFloat32(14, float32, 0.0);
}

static add_long(builder:flatbuffers.Builder, long:bigint) {
  builder.addFieldInt64(15, long, BigInt('0'));
}

static add_int64(builder:flatbuffers.Builder, int64:bigint) {
  builder.addFieldInt64(16, int64, BigInt('0'));
}

static add_ulong(builder:flatbuffers.Builder, ulong:bigint) {
  builder.addFieldInt64(17, ulong, BigInt('0'));
}

static add_uint64(builder:flatbuffers.Builder, uint64:bigint) {
  builder.addFieldInt64(18, uint64, BigInt('0'));
}

static add_double(builder:flatbuffers.Builder, double:number) {
  builder.addFieldFloat64(19, double, 0.0);
}

static add_float64(builder:flatbuffers.Builder, float64:number) {
  builder.addFieldFloat64(20, float64, 0.0);
}

static add_string(builder:flatbuffers.Builder, stringOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, stringOffset, 0);
}

static endTypeCheck(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishTypeCheckBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
}

static finishSizePrefixedTypeCheckBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
}

static createTypeCheck(builder:flatbuffers.Builder, byte:number, int8:number, ubyte:number, uint8:number, bool:boolean, short:number, int16:number, ushort:number, uint16:number, int:number, int32:number, uint:number, uint32:number, float:number, float32:number, long:bigint, int64:bigint, ulong:bigint, uint64:bigint, double:number, float64:number, stringOffset:flatbuffers.Offset):flatbuffers.Offset {
  TypeCheck.startTypeCheck(builder);
  TypeCheck.add_byte(builder, byte);
  TypeCheck.add_int8(builder, int8);
  TypeCheck.add_ubyte(builder, ubyte);
  TypeCheck.add_uint8(builder, uint8);
  TypeCheck.add_bool(builder, bool);
  TypeCheck.add_short(builder, short);
  TypeCheck.add_int16(builder, int16);
  TypeCheck.add_ushort(builder, ushort);
  TypeCheck.add_uint16(builder, uint16);
  TypeCheck.add_int(builder, int);
  TypeCheck.add_int32(builder, int32);
  TypeCheck.add_uint(builder, uint);
  TypeCheck.add_uint32(builder, uint32);
  TypeCheck.add_float(builder, float);
  TypeCheck.add_float32(builder, float32);
  TypeCheck.add_long(builder, long);
  TypeCheck.add_int64(builder, int64);
  TypeCheck.add_ulong(builder, ulong);
  TypeCheck.add_uint64(builder, uint64);
  TypeCheck.add_double(builder, double);
  TypeCheck.add_float64(builder, float64);
  TypeCheck.add_string(builder, stringOffset);
  return TypeCheck.endTypeCheck(builder);
}

unpack(): TypeCheckT {
  return new TypeCheckT(
    this.byte(),
    this.int8(),
    this.ubyte(),
    this.uint8(),
    this.bool(),
    this.short(),
    this.int16(),
    this.ushort(),
    this.uint16(),
    this.int(),
    this.int32(),
    this.uint(),
    this.uint32(),
    this.float(),
    this.float32(),
    this.long(),
    this.int64(),
    this.ulong(),
    this.uint64(),
    this.double(),
    this.float64(),
    this.string()
  );
}


unpackTo(_o: TypeCheckT): void {
  _o.byte = this.byte();
  _o.int8 = this.int8();
  _o.ubyte = this.ubyte();
  _o.uint8 = this.uint8();
  _o.bool = this.bool();
  _o.short = this.short();
  _o.int16 = this.int16();
  _o.ushort = this.ushort();
  _o.uint16 = this.uint16();
  _o.int = this.int();
  _o.int32 = this.int32();
  _o.uint = this.uint();
  _o.uint32 = this.uint32();
  _o.float = this.float();
  _o.float32 = this.float32();
  _o.long = this.long();
  _o.int64 = this.int64();
  _o.ulong = this.ulong();
  _o.uint64 = this.uint64();
  _o.double = this.double();
  _o.float64 = this.float64();
  _o.string = this.string();
}
}

export class TypeCheckT implements flatbuffers.IGeneratedObject {
constructor(
  public byte: number = 0,
  public int8: number = 0,
  public ubyte: number = 0,
  public uint8: number = 0,
  public bool: boolean = false,
  public short: number = 0,
  public int16: number = 0,
  public ushort: number = 0,
  public uint16: number = 0,
  public int: number = 0,
  public int32: number = 0,
  public uint: number = 0,
  public uint32: number = 0,
  public float: number = 0.0,
  public float32: number = 0.0,
  public long: bigint = BigInt('0'),
  public int64: bigint = BigInt('0'),
  public ulong: bigint = BigInt('0'),
  public uint64: bigint = BigInt('0'),
  public double: number = 0.0,
  public float64: number = 0.0,
  public string: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const string = (this.string !== null ? builder.createString(this.string!) : 0);

  return TypeCheck.createTypeCheck(builder,
    this.byte,
    this.int8,
    this.ubyte,
    this.uint8,
    this.bool,
    this.short,
    this.int16,
    this.ushort,
    this.uint16,
    this.int,
    this.int32,
    this.uint,
    this.uint32,
    this.float,
    this.float32,
    this.long,
    this.int64,
    this.ulong,
    this.uint64,
    this.double,
    this.float64,
    string
  );
}
}
