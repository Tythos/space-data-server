// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class MPE implements flatbuffers.IUnpackableObject<MPET> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MPE {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMPE(bb:flatbuffers.ByteBuffer, obj?:MPE):MPE {
  return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMPE(bb:flatbuffers.ByteBuffer, obj?:MPE):MPE {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

MEAN_MOTION():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

ECCENTRICITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

INCLINATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

RA_OF_ASC_NODE():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

ARG_OF_PERICENTER():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

MEAN_ANOMALY():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

NORAD_CAT_ID():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

BSTAR():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

USER_DEFINED_EPOCH_TIMESTAMP():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

static startMPE(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addMeanMotion(builder:flatbuffers.Builder, MEAN_MOTION:number) {
  builder.addFieldFloat64(0, MEAN_MOTION, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, ECCENTRICITY:number) {
  builder.addFieldFloat64(1, ECCENTRICITY, 0.0);
}

static addInclination(builder:flatbuffers.Builder, INCLINATION:number) {
  builder.addFieldFloat64(2, INCLINATION, 0.0);
}

static addRaOfAscNode(builder:flatbuffers.Builder, RA_OF_ASC_NODE:number) {
  builder.addFieldFloat64(3, RA_OF_ASC_NODE, 0.0);
}

static addArgOfPericenter(builder:flatbuffers.Builder, ARG_OF_PERICENTER:number) {
  builder.addFieldFloat64(4, ARG_OF_PERICENTER, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, MEAN_ANOMALY:number) {
  builder.addFieldFloat64(5, MEAN_ANOMALY, 0.0);
}

static addNoradCatId(builder:flatbuffers.Builder, NORAD_CAT_ID:number) {
  builder.addFieldInt32(6, NORAD_CAT_ID, 0);
}

static addBstar(builder:flatbuffers.Builder, BSTAR:number) {
  builder.addFieldFloat64(7, BSTAR, 0.0);
}

static addUserDefinedEpochTimestamp(builder:flatbuffers.Builder, USER_DEFINED_EPOCH_TIMESTAMP:number) {
  builder.addFieldFloat64(8, USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
}

static endMPE(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createMPE(builder:flatbuffers.Builder, MEAN_MOTION:number, ECCENTRICITY:number, INCLINATION:number, RA_OF_ASC_NODE:number, ARG_OF_PERICENTER:number, MEAN_ANOMALY:number, NORAD_CAT_ID:number, BSTAR:number, USER_DEFINED_EPOCH_TIMESTAMP:number):flatbuffers.Offset {
  MPE.startMPE(builder);
  MPE.addMeanMotion(builder, MEAN_MOTION);
  MPE.addEccentricity(builder, ECCENTRICITY);
  MPE.addInclination(builder, INCLINATION);
  MPE.addRaOfAscNode(builder, RA_OF_ASC_NODE);
  MPE.addArgOfPericenter(builder, ARG_OF_PERICENTER);
  MPE.addMeanAnomaly(builder, MEAN_ANOMALY);
  MPE.addNoradCatId(builder, NORAD_CAT_ID);
  MPE.addBstar(builder, BSTAR);
  MPE.addUserDefinedEpochTimestamp(builder, USER_DEFINED_EPOCH_TIMESTAMP);
  return MPE.endMPE(builder);
}

unpack(): MPET {
  return new MPET(
    this.MEAN_MOTION(),
    this.ECCENTRICITY(),
    this.INCLINATION(),
    this.RA_OF_ASC_NODE(),
    this.ARG_OF_PERICENTER(),
    this.MEAN_ANOMALY(),
    this.NORAD_CAT_ID(),
    this.BSTAR(),
    this.USER_DEFINED_EPOCH_TIMESTAMP()
  );
}


unpackTo(_o: MPET): void {
  _o.MEAN_MOTION = this.MEAN_MOTION();
  _o.ECCENTRICITY = this.ECCENTRICITY();
  _o.INCLINATION = this.INCLINATION();
  _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
  _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
  _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
  _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
  _o.BSTAR = this.BSTAR();
  _o.USER_DEFINED_EPOCH_TIMESTAMP = this.USER_DEFINED_EPOCH_TIMESTAMP();
}
}

export class MPET implements flatbuffers.IGeneratedObject {
constructor(
  public MEAN_MOTION: number = 0.0,
  public ECCENTRICITY: number = 0.0,
  public INCLINATION: number = 0.0,
  public RA_OF_ASC_NODE: number = 0.0,
  public ARG_OF_PERICENTER: number = 0.0,
  public MEAN_ANOMALY: number = 0.0,
  public NORAD_CAT_ID: number = 0,
  public BSTAR: number = 0.0,
  public USER_DEFINED_EPOCH_TIMESTAMP: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return MPE.createMPE(builder,
    this.MEAN_MOTION,
    this.ECCENTRICITY,
    this.INCLINATION,
    this.RA_OF_ASC_NODE,
    this.ARG_OF_PERICENTER,
    this.MEAN_ANOMALY,
    this.NORAD_CAT_ID,
    this.BSTAR,
    this.USER_DEFINED_EPOCH_TIMESTAMP
  );
}
}
